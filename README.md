# Homework 
## Дедлайн - 26 февраля 15:30

В папке /src все примеры по concurrency с первых двух лекций

## Task 1
### 2 балла
Рядом с исполняемым кодом в папке resources нужно создать файл data.txt, в который через пробел записать рандомные числа. Далее в два потоков нужно найти максимум и минимум среди этих чисел. Рядом напишите метод, не испоьлзующий параллельность, и выполняющий то же самое. Сравните полученные результаты.

## Task 2
### 2 балла
Создайте несколько потоков, которые будут одновременно печатать в консоль свои идентификаторы (например, имена потоков) определенное количество раз. Имена и количество повторений должны передаваться параметрами в конструктор каждого потока.

## Task 3
### 2 балла
Реализуйте два потока: первый поток заполняет массив числами, второй поток ждёт, пока массив не будет заполнен, и после этого выводит массив на экран. Используйте `wait()` и `notify()`

## Task 4
### 2 балла
Реализуйте два потока, которые должны печатать числа от 1 до 10 по очереди. Один поток печатает нечетные числа, второй — четные. Используйте синхронизацию и общий `Object lock` для потоков (потоки можно реализовать как вложенные static классы).

## Task 5
### 1 балл
Нужно сделать удаление, чтение и добавление заметок потокобезопасным. Лучше всего использовать ReentrantReadWriteLock и синхронизировать только критические секции.

```java
public class Note {

        public final List<String> notes = new ArrayList<>();

        public void addNote(int index, String note) {
            System.out.println("Сейчас будет добавлена заметка [" + note + "] На позицию " + index);
            notes.add(index, note);
            System.out.println("Уже добавлена заметка [" + note + "]");
        }

        public void removeNote(int index) {
            System.out.println("Сейчас будет удалена заметка с позиции " + index);
            String note;
            note = notes.remove(index);
            System.out.println("Уже удалена заметка [" + note + "] с позиции " + index);
        }
        
        public void readNote(int index) {
            System.out.println("Сейчас будет прочтена заметка с позиции " + index);
            String note;
            note = notes.get(index);
            System.out.println("Прочтена заметка [" + note + "] с позиции " + index);
        }
    }
```

## Task 6
### 2 балла
Пусть есть объект сундук, который в несколько потоков заполняется золотом(воспользуйтесь ExecutorService). Реализуйте логику такой работы,при которой итоговый ответ (общее количество золота) будет корректно выводиться.

## Task 7
### 5 баллов

Реализуйте метод calculateHorsesFinished. Он должен:

1. Посчитать количество финишировавших лошадей и возвратить его. Нужно использовать метод `isFinished()`.
2. Если лошадь еще не пришла к финишу (`!isFinished()`), то:
   1. Вывести в консоль `"Waiting for " + horse.getName()`.
   2. Подождать, пока она завершит гонку.
   3. Не считать такую лошадь финишировавшей.

```java
public class Solution {

    public static void main(String[] args) throws InterruptedException {
        List<Horse> horses = prepareHorsesAndStart(10);
        while (calculateHorsesFinished(horses) != horses.size()) {
        }
    }

    public static int calculateHorsesFinished(List<Horse> horses) throws InterruptedException {
        int finishedCount = 0;
        //напишите тут ваш код
        
        return finishedCount;
    }

    public static List<Horse> prepareHorsesAndStart(int horseCount) {
        List<Horse> horses = new ArrayList<>(horseCount);
        String number;
        for (int i = 1; i < horseCount + 1; i++) {
            number = i < 10 ? ("0" + i) : "" + i;
            horses.add(new Horse("Horse_" + number));
        }

        for (int i = 0; i < horseCount; i++) {
            horses.get(i).start();
        }
        return horses;
    }

    public static class Horse extends Thread {

        private boolean isFinished;

        public Horse(String name) {
            super(name);
        }

        public boolean isFinished() {
            return isFinished;
        }

        public void run() {
            String s = "";
            for (int i = 0; i < 1001; i++) {   // Delay
                s += "" + i;
                if (i == 1000) {
                    s = " has finished the race!";
                    System.out.println(getName() + s);
                    isFinished = true;
                }
            }
        }
    }
}
```

## Task 8
### 7 баллов

<image src="/Lesson 1 Spring term/images/корабли.jpeg" alt="Текст с описанием картинки">

- Есть транспортные корабли, которые подплывают к туннели и далее плывут к причалам для погрузки разного рода товара.
- Они проходят через узкий туннель где одновременно могут находиться только 5 кораблей. Под словом “подплывают к туннели” имеется ввиду то, что корабли должны откуда-то появляться. Их может быть ограниченное количество, то есть 10 или 100, а может быть бесконечное множество. Слово “Подплывают” назовем генератором кораблей.
- Вид кораблей и их вместительность могут быть разными в зависимости от типа товаров, которые нужно загрузить на корабль. Пусть есть 3 Типа кораблей (Хлеб, Банан и Одежда) и три вида вместительности 10, 50, 100 шт. товаров. 3 типа кораблей * 3 вида вместительности = 9 разных видов кораблей.
- Далее есть 3 вида причалов для погрузки кораблей — Хлеб, Банан и Одежда. Каждый причал берет или подзывает к себе необходимый ему корабль и начинает его загружать. За одну секунду причал загружает на корабль 10 ед. товара. То есть если у корабля вместительность 50 шт., то причал загрузит его за 5 секунд своей работы.

#### Требования такие:
- Правильно разбить задачу на параллельность.
- Синхронизировать потоки, сохранить целостность данных. Ведь ограничить доступ потоков к общему ресурсу дело не сложное, а заставить их работать согласованно уже намного сложнее.
- Работа генератора кораблей не должна зависеть от работы причалов и наоборот.
- Общий ресурс должен быть Thread Safe (Если таковой есть в реализации)
- Потоки не должны быть активными если нет задач.
- Потоки не должны держать mutex если нет задач.

## Task 9
### 18 баллов
В ресторане присутствует онлайн система заказов, где клиенты могут делать заказы через интернет. Ваша задача — разработать многопоточное приложение для управления этими заказами. Приложение должно включать в себя следующие компоненты:

1. **Потокобезопасный список заказов:** Заказы, поступающие онлайн, сохраняются в потокобезопасный список (например, `ConcurrentLinkedQueue`). Каждый заказ содержит список блюд и уникальный идентификатор.

2. **Повара:** Несколько поваров обрабатывают заказы параллельно. Каждый повар может обрабатывать только один заказ одновременно. После того как повар закончит обработку заказа, он отправляет уведомление о готовности.

3. **Официанты:** Официанты отвечают за доставку заказов клиентам. После того как заказ обработан поваром, официант выбирает его и делает отметку о доставке.

4. **ExecutorService:** Используйте `ExecutorService` для управления потоками поваров и официантов.

5. **Locks и Conditions:** Используйте механизмы из пакета `java.util.concurrent.locks` для синхронизации доступа к ресурсам и управления состоянием выполнения задач.

- Разработайте метод для безопасного добавления заказов в список.
- Реализуйте механизм, позволяющий повару выбирать заказ из списка, обрабатывать его и сообщать об окончании обработки.
- Обеспечьте механизм, с помощью которого официанты могут выбирать готовые заказы и отмечать их как доставленные.
- Гарантируйте, что каждый заказ будет обработан ровно одним поваром и доставлен ровно одним официантом.
