# Homework 
## Дедлайн - 23 октября 15:30
Ниже приведены задачи, функциональность каждой нужно проверить в методе main. Если проверка будет сделана через assert(там, где это возможно): +1 балл. 

## Task 1
### 3 балла
Реализуйте интерфей и класс, который позволит работать с обобщенными двумерными матрицами. В классе должны быть конструкторы (дефолтный и на основе другой матрицы), метод добавления нового элемента, методы удаления и получения элемента по индексу.

## Task 2
### 4 балла
Реализуйте класс Tuple - кортеж произвольной длины обобщенных элементов (Если создан кортеж длины 5, то работа с указанными пятью индексами должна быть доступна и валидна, а вот с 6 и более уже нет, то есть кортеж - это как список фиксированной длины). Должен быть предоставлен конструктор Tuple(int capacity), задающий вместимость кортежа. Реализуйте методы get(int index) - получение по индексу, add(E el) и add(E el, int index) - в первом случае элемент добавляется на первую свободную позицию (перетирать существующие значения нельзя), во втором добавляется по индексу - тут перетирать значения можно, remove(int index) и remove(T el). Также должны быть методы isEmpty(), orElse(int i, T default). Предусмотрите и обработайте возможные исключения, которые могут возникнуть при работе с кортежем. Пользоваться стандартными коллекциями(списки, хэш-таблици и все такое) внутри класса Tuple нельзя.

## Task 3
### 2 балл
Реализуйте обобщенный класс Pair<T>, как в примере с лекции, но добавьте два метода min() и max() - которые будут возвращать соответствующий элемент из пары. Добавьте нужные ограничения на тип T (почитайте про интерфейс Comparable).

## Task 4
### 2 балла
Реализуйте обобщенный метод minMax(T arr), который будет возвращать объект Pair с минимальным и максимальным элементом массива. 

## Task 5
### 2 балл
Реализуйте метод map(), принимающий на вход список (посмотрите про Интерфейс List) и объект типа Function<T, R> - это функциональный интерфейс из стандартной библиотеке, посмотрите про него сами. Метод map должен возвращать список, состоящий из элементов входного списка, к которым была применена функция из Function. Подумайте об ограничении типов T и R в Function в параметрах метода (extends, super)
